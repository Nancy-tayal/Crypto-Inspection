# -*- coding: utf-8 -*-
"""Crypto currency Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r0Zq9w9RugCbmeijXrkqvgmTG23e9gDP

#Import Library
"""

import numpy as np
import pandas as pd
from pandas import DataFrame
import matplotlib.pyplot as plt

"""# **Overview of dataset using Pandas_Profiling**"""

pip install pandas-profiling==2.7.1

from pandas_profiling import ProfileReport

df=pd.read_csv('/content/top_Five.csv')
df

profile =ProfileReport(df,title="Pandas Profiling Report")

profile.to_widgets()

profile.to_notebook_iframe()

"""# **Self Analysis of Dataset**"""

top_data=pd.read_csv('/content/top_Five.csv')

top_data['Date'] = top_data['Date'].apply(lambda x:x[0:10])
top_data.set_index('Date', inplace=True)
top_data

top_data.shape

"""#Extracting the Bitcoin Data"""

bit_coin=top_data.loc[top_data['Name'].str.contains("Bitcoin", case=False)] #contains function is pattern match to string its regex method

bit_coin

bit_coin.describe()

"""#Extracting the Ethereum coin"""

Ethereum_coin = top_data.loc[top_data['Name'].str.contains("Ethereum", case=False)]

Ethereum_coin

Ethereum_coin.describe()

"""#Extracting the XRP coin"""

XRP_coin=top_data.loc[top_data['Name'].str.contains("XRP", case=False)]

XRP_coin

XRP_coin.describe()

"""#Find Cardano coin"""

Cardano_coin=top_data.loc[top_data['Name'].str.contains("Cardano", case=False)]

Cardano_coin

Cardano_coin.describe()

"""#Find Stellar coin"""

Stellar_coin=top_data.loc[top_data['Name'].str.contains("Stellar", case=False)]

Stellar_coin

Stellar_coin.describe()

"""# Dependence of High, Low, Open and Close on each other"""

fig, ax1 = plt.subplots(5, figsize=(20,35))
title =["Bitcoin: Features Inter-Dependence Graph","Ethereum: Features Inter-Dependence Graph",
        "XRP: Features Inter-Dependence Graph","Cardano: Features Inter-Dependence Graph","Stellar:Features Inter-Dependence Graph"]
bit_coin[["High","Low","Open","Close"]].plot(ax=ax1[0])
Ethereum_coin[["High","Low","Open","Close"]].plot(ax=ax1[1])
XRP_coin[["High","Low","Open","Close"]].plot(ax=ax1[2])
Cardano_coin[["High","Low","Open","Close"]].plot(ax=ax1[3])
Stellar_coin[["High","Low","Open","Close"]].plot(ax=ax1[4])
for i in range(5):
  ax1[i].set_title(title[i], pad=-20, fontsize=20)
plt.show()

"""# Maximum returns"""

plt.figure(figsize=(12,10))
plt.plot(bit_coin['Close']*100/bit_coin['Close'].iloc[0])
plt.plot(Ethereum_coin['Close']*100/Ethereum_coin['Close'].iloc[0] )
plt.plot(XRP_coin['Close']*100/XRP_coin['Close'].iloc[0] )
plt.plot(Cardano_coin['Close']*100/Cardano_coin['Close'].iloc[0] )
plt.plot(Stellar_coin['Close']*100/Stellar_coin['Close'].iloc[0] )
plt.legend(['Bitcoin','Ethereum','XRP','Cardano','Stellar'], loc='best')
plt.title("Maximum returns")
plt.xlabel("Days")
plt.ylabel("Increase %")
plt.xticks([0,100,200,300,400,500,600,700,800,900])
plt.show()

"""# Charts to Depict the Inter-Dependence among Currencies """

#scaling the data
from sklearn.preprocessing import MinMaxScaler
scaler=MinMaxScaler()
coindf1=pd.DataFrame({'BTC':bit_coin["High"],'ETH':Ethereum_coin["High"], 'XRP':XRP_coin["High"],'ADA':Cardano_coin["High"],'XLM':Stellar_coin["High"]})
coindf1.plot(figsize=(7,7)) # Data won't be presented very well as they are having different scales
plt.show()
df1= pd.DataFrame(scaler.fit_transform(coindf1), columns=["BTC","ETH","XRP","ADA","LMX"], index=bit_coin.index) # Scaling the data
print(df1)

df1[700:].plot(figsize=(12,10))
plt.title("Graph to show the effect of spike or dip in price of a crypto on other crypto", size=20)
plt.xlabel('Date', size=15, labelpad=10)
plt.ylabel('Price (Scaled)',size=15,labelpad=10)
plt.show()

df2 = pd.DataFrame(coindf1.pct_change(), index=bit_coin.index)
df2.dropna(inplace=True)
df2[700:].plot(figsize=(12,10))
plt.title("Graph to show the effect of spike in price of a crypto on other crypto (in terms of return)", size=20)
plt.xlabel('Date', size=15, labelpad=10)
plt.ylabel('Return(%)',size=15,labelpad=10)
plt.ylim(-.75,.75)
plt.show()

df2.boxplot()
plt.title("Return Summary")
plt.show()
df2.boxplot( showfliers=False)
plt.title("Return Summary excluding outliers")
plt.show()

"""# Correlation Among the features of each currency"""

import seaborn as sb
fig,ax1 = plt.subplots(3,2,figsize=(20,20))
plt.suptitle("Features Correlation", size=20)
sb.heatmap(bit_coin.corr(), annot=True,ax=ax1[0][0])
ax1[0][0].set_title("Bitcoin", size=15)
sb.heatmap(Ethereum_coin.corr(), annot=True,ax=ax1[0][1])
ax1[0][1].set_title("Ethereum", size=15)
sb.heatmap(XRP_coin.corr(), annot=True,ax=ax1[1][0])
ax1[1][0].set_title("XRP", size=15)
sb.heatmap(Cardano_coin.corr(), annot=True,ax=ax1[1][1])
ax1[1][1].set_title("Cardano", size=15)
sb.heatmap(Stellar_coin.corr(), annot=True,ax=ax1[2][0])
ax1[2][0].set_title("Stellar", size=15)
ax1[2][1].axis('off')
plt.show()

"""# Correlation Between The Cryptocurrencies"""

tc = df1.corr()
print(tc)
sb.heatmap(tc, annot=True)
plt.show()

sb.pairplot(df1)
plt.show()

"""# Volatility of Crypto"""

yeardf = pd.DataFrame({'BTC':bit_coin["High"],'ETH':Ethereum_coin["High"], 'XRP':XRP_coin["High"],'ADA':Cardano_coin["High"],'XLM':Stellar_coin["High"]}, index=bit_coin.index)
df2=yeardf.pct_change()# for calculating the percentage change (return)
df2.dropna(inplace=True)
fig, ax1 = plt.subplots(5, figsize=(20,20))
df2['BTC'].plot(ax =ax1[0], ylim=[-1,1], fontsize=12, color='r', legend=True)
df2['ETH'].plot(ax =ax1[1], ylim=[-1,1], fontsize=12, color='b', legend=True)
df2['XRP'].plot(ax =ax1[2], ylim=[-1,1], fontsize=12, color='g', legend=True)
df2['ADA'].plot(ax =ax1[3], ylim=[-1,1], fontsize=12, color='m', legend=True)
df2['XLM'].plot(ax =ax1[4], ylim=[-1,1], fontsize=12, color='y', legend=True)
for i in range(5):
  ax1[i].set_xlabel("Date", size=15)
  ax1[i].set_ylabel("Return(%)", size=15)
plt.show()

"""# Return Distribution"""

fig, ax = plt.subplots(3,2, figsize=(25,25))
title=[["Bitcoin","Ethereum"],["XRP", "Cardano"],["Stellar",""]]
ax[0][0].hist(df2['BTC'],bins=100,color='r', range=(-0.15,0.15))
ax[0][1].hist(df2['ETH'],bins=100, color='g',range=(-0.15,0.15))
ax[1][0].hist(df2['XRP'],bins=100,color='b',range=(-0.15,0.15))
ax[1][1].hist(df2['ADA'],bins=100, color='m',range=(-0.15,0.15))
ax[2][0].hist(df2['XLM'],bins=100,color='y',range=(-0.15,0.15))
plt.legend(loc='best')
for i in range(3):
  for j in range(2):
    ax[i][j].set_title(title[i][j], size=20)
    ax[i][j].set_xlabel('return (%)', size=15, labelpad=10)
    ax[i][j].set_ylabel('count (Days)',size=15,labelpad=10)
ax[2][1].axis('off')
plt.suptitle("Return Distribution", size=25)
plt.show()

"""# Summary of return"""

df2.boxplot()
plt.show()
df2.boxplot( showfliers=False)
plt.show()

"""# Loking at the plot of Market Capital vs Date to know which currency is leading """

df = pd.DataFrame({'BTC':bit_coin["Marketcap"],'ETH':Ethereum_coin["Marketcap"],'XRP':XRP_coin["Marketcap"],'ADA':Cardano_coin["Marketcap"],'XLM':Stellar_coin["Marketcap"]}, index=bit_coin.index)
df.plot(figsize=(12,10), ylabel='Market Capital(10^12)')

fig,ax = plt.subplots(3,2,figsize=(20,20))
df['BTC'].plot(ax=ax[0][0], color='r')
ax[0][0].set_title('Bitcoin')
df['ETH'].plot(ax=ax[0][1], color='b')
ax[0][1].set_title('Ethereum')
df['XRP'].plot(ax=ax[1][0], color='g')
ax[1][0].set_title('XRP')
df['ADA'].plot(ax=ax[1][1], color='m')
ax[1][1].set_title('Cardano')
df['XLM'].plot(ax=ax[2][0], color='y')
ax[2][0].set_title('Stellar')
ax[2][1].axis('off')

plt.pie(df.iloc[-1], explode=(0.1, 0.1, 0.1, 0.1,0.1), autopct = '%1.1f%%', shadow = True,labels=['Bitcoin', 'Ethereum', 'XRP', 'Cardano', 'Stellar'])
plt.show()

"""# Cryptocurrency Volume"""

df = pd.DataFrame({'BTC':bit_coin["Volume"],'ETH':Ethereum_coin["Volume"], 'XRP':XRP_coin["Volume"],'ADA':Cardano_coin["Volume"],'XLM':Stellar_coin["Volume"]}, index=bit_coin.index)
df.plot(figsize=(10,10), ylabel="Number of units(1o^11)")

fig,ax = plt.subplots(3,2,figsize=(20,20))
df['BTC'].plot(ax=ax[0][0], color='r')
ax[0][0].set_title('Bitcoin')
df['ETH'].plot(ax=ax[0][1], color='b')
ax[0][1].set_title('Ethereum')
df['XRP'].plot(ax=ax[1][0], color='g')
ax[1][0].set_title('XRP')
df['ADA'].plot(ax=ax[1][1], color='m')
ax[1][1].set_title('Cardano')
df['XLM'].plot(ax=ax[2][0], color='y')
ax[2][0].set_title('Stellar')
ax[2][1].axis('off')

"""#Maximum Highest value and Minimum Highest value of bit coin Accroding to closing"""

bit_max=bit_coin[bit_coin['Close']==max(bit_coin.Close)]

bit_max

bit_min=bit_coin[bit_coin['Close']==min(bit_coin.Close)]

bit_min

plt.plot(bit_max['High'],'o-',bit_min['High'],'-o')
plt.legend(loc='best')
plt.title('min value bitcoin')
plt.legend(['max High','min high'])
plt.show()

"""#Maximum Highest value and Minimum Highest value of Ethereum Accroding to closing"""

Ethereum_max=Ethereum_coin[Ethereum_coin['Close']==max(Ethereum_coin.Close)]

Ethereum_max

Ethereum_min=Ethereum_coin[Ethereum_coin['Close']==min(Ethereum_coin.Close)]

Ethereum_min

plt.plot(Ethereum_max['High'],'o-',Ethereum_min['High'],'-o')
plt.legend(loc='best')
plt.title('Ethereum min value')
plt.legend(['Max High','Min High'])
plt.show()

"""#Maximum Highest value and Minimum Highest value of XRP Accroding to Closing"""

XRP_max=XRP_coin[XRP_coin['Close']==max(XRP_coin.Close)]

XRP_max

XRP_min=XRP_coin[XRP_coin['Close']==min(XRP_coin.Close)]

XRP_min

plt.plot(XRP_max['High'],'o-',XRP_min['High'],'-o')
plt.legend(loc='best')
plt.title('XRP min Value')
plt.legend(['Max High','Min High'])
plt.show()

"""#Maximum Highest value and Minimum Highest value of Cardano Accroding to Closing"""

Cardano_max=Cardano_coin[Cardano_coin['Close']==max(Cardano_coin.Close)]

Cardano_max

Cardano_min=Cardano_coin[Cardano_coin['Close']==min(Cardano_coin.Close)]

Cardano_min

plt.plot(Cardano_max['High'],'o-',Cardano_min['High'],'-o')
plt.legend(loc='best')
plt.title('min pric')
plt.legend(['Max High','Min High'])
plt.show()

"""#Maximum Highest value and Minimum Highest value of Stellar Accroding to Closing"""

Stellar_max=Stellar_coin[Stellar_coin['Close']==max(Stellar_coin.Close)]

Stellar_max

Stellar_min=Stellar_coin[Stellar_coin['Close']==min(Stellar_coin.Close)]

Stellar_min

plt.plot(Stellar_max['High'],'o-',Stellar_min['High'],'-o')
plt.legend(loc='best')
plt.title('Min high and low price')

plt.legend(['Max High','Min High'])
plt.show()

"""#KNN Model"""

X= np.array(bit_coin['Close']).reshape(-1,1) #one columns 2d
print(X.tolist())

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt

plt.plot(X)

dist_sq = np.sum((X[:,np.newaxis,:] - X[np.newaxis,:,:]) ** 2, axis=-1)
dist_sq

# for each pair of points, compute differences in their coordinates
differences = X[:, np.newaxis, :] - X[np.newaxis, :, :]

differences.shape

#import sys
K = 2
nearest_partition = np.argpartition(dist_sq, K + 1, axis=1)

#np.set_printoptions(threshold=sys.maxsize) see full data near by


#nearest partion matrix in index shape according
nearest_partition

# Using Scikit Learn
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix
x = top_data.iloc[:, 2:].values
y = top_data.iloc[:, 0].values
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.20)
s = StandardScaler()
s.fit(x_train)
x_train = s.transform(x_train)
x_test = s.transform(x_test)
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(x_train, y_train)
y_pred = knn.predict(x_test)
print(y_pred)

cm = confusion_matrix(y_test, y_pred)
print(cm)

print("Score is",knn.score(x_test,y_test)) # Accuracy

"""# Linear Regression Model"""

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split

def split(x,y):
  xtrain, xtest, ytrain, ytest = train_test_split(x, y, test_size = 0.3, 
                                                     random_state = 0)
  return(xtrain, ytrain, xtest, ytest)
def pred(x, y, x_pred):
  regr = LinearRegression()
  regr.fit(x,y)
  pred_y = regr.predict(x_pred)
  print('Predicted Marketcap Values:',pred_y.tolist())
  print('Regression Coefficients:',regr.coef_)
  print('Intercept:',regr.intercept_)
  print('R-squared:',regr.score(x,y))
  return pred_y

def plot_regression_line(x, y, y_pred):
    plt.scatter(x, y, color ="r")
    plt.plot(x, y_pred, 'g')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.show()

def main():
  x = bit_coin[["High","Low","Open","Close"]].values
  y = Ethereum_coin["High"].values.reshape(-1,1)
  inp = split(x,y)
  pred_y = pred(inp[0],inp[1],inp[2])
  if len(x[0])==1:
    plot_regression_line(inp[2],inp[3],pred_y)

if __name__ == "__main__":
  main()

"""# ARIMA Model"""

pip install pmdarima

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller

df=XRP_coin
df
#df.set_index(index=df.index, drop=True, inplace = True)
df=df.dropna()
print('Shape: ',df.shape)
df.head()

df['Close']

df['Close'].plot(figsize=(12,5))

def ad_test(dataset):
    dftest=adfuller(dataset,autolag='AIC')
    print('1. ADF: ',dftest[0])
    print('2. p-value: ',dftest[1])
    print('3. No. of lags: ',dftest[2])
    print('4. No. of observations used for ADF regression and critical values calculation: ',dftest[3])
    print('5. Critical Values: ')
    for key, val in dftest[4].items():
        print('\t',key,': ',val)

ad_test(df['Close'])

from pmdarima import auto_arima

import warnings
warnings.filterwarnings('ignore')

stepwise_fit=auto_arima(df['Close'],trace=True,suppress_warnings=True)
stepwise_fit.summary()

from statsmodels.tsa.arima_model import ARIMA

print(df.shape)
train=df.iloc[:-100]
test=df.iloc[-100:]
print(train.shape,train.shape)

model=ARIMA(train['Close'],order=(1,1,1))
model=model.fit()
model.summary()

start=len(train)
end=len(train)+len(test)-1
pred=model.predict(start=start,end=end,typ='levels')
pred.index=df.index[start:end+1]
print(pred)

pred.plot(legend=True)
test['Close'].plot(legend=True)

test['Close'].mean()

from sklearn.metrics import mean_squared_error
from math import sqrt
rmse=sqrt(mean_squared_error(pred,test['Close']))
print(rmse)

model2=ARIMA(df['Close'],order=(1,1,1))
model2=model2.fit()
df.tail()

index_future_dates=pd.date_range(start='27-02-2021',end='29-03-2021')
pred=model2.predict(start=len(df),end=len(df)+30,typ='levels').rename('ARIMA Predictions')
pred.index=index_future_dates
print(pred)

pred.plot(figsize=(12,5),legend=True, xlabel='Date', ylabel='Close',)

"""# SARIMA MODEL """

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import itertools
import datetime as dt

# Visualization
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline


# TSA from Statsmodels
import statsmodels.api as sm
import statsmodels.tsa.api as smt
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.seasonal import seasonal_decompose
# from statsmodels.tsa.holtwinters import ExponentialSmoothing

import warnings
warnings.filterwarnings("ignore")

data = pd.read_csv('/content/top_Five.csv')
data.head()

data.info()

plt.figure(figsize=[15, 7.5]); # Set dimensions for figure
plt.plot(data['date'], data['data'])
plt.title('Quarterly EPS for Johnson & Johnson')
plt.ylabel('EPS per share ($)')
plt.xlabel('Date')
plt.xticks(rotation=90)
plt.grid(True)
plt.show()

my_order = (1, 1, 1)
my_seasonal_order = (1, 1, 1, 3)
model = SARIMAX(data,exog = 'None',order = my_order,seasonal_order = my_seasonal_order)
model_fit = model.fit()
predict_model = model_fit.forecast()
predict_model = model_fit.predict(start=len(data), end=len(data))